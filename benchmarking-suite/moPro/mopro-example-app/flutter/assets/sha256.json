{"noir_version":"1.0.0-beta.8+ba05d729b9753aa5ce2b076c1dd4795edb173f68","hash":"8292800804970152055","abi":{"parameters":[{"name":"input","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6668324276689745315":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"use dep::sha256::digest;\n\nfn main(input: [u8; 32]) -> pub [u8; 32] {\n     digest(input)\n}\n","path":"/Users/mohitgrover/Desktop/Projects/PR Diemos/Deimos/benchmarking-suite/frameworks/noir/circuits/sha256/src/main.nr"},"53":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n","path":"/Users/mohitgrover/nargo/github.com/noir-lang/sha256/v0.1.0/src/sha256.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","directive_integer_quotient","directive_to_radix"]}