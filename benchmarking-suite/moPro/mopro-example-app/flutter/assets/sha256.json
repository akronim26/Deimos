{"noir_version":"1.0.0-beta.13+6e469c3004209a8b107e7707306e25c80a110fd6","hash":"13501715813230201520","abi":{"parameters":[{"name":"input","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"11019205087382408538":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"rZvdbtxIDoXfxde5UP2RrLzKIAicxDMwYDiBJ15gEfjdl6ziodoLSI6rc5P62q0+ZP0cqSQxv26+3X15/ufz/ePf3/+9+fjXr5svT/cPD/f/fH74/vX25/33R/3rr5vN/pFy87HRhxup3jZvyVv2Vrzts+2bt8nb7K3rddfrrtddr7ted73uemkzQTYwBTGogAYggKl0haRhaTMogApoDtmOSQYFUAENoMqUDRgggO5QNEMqBnZMVaj2l2ZgIawXtQAqwEJYvyoBGCCA7tBMxzrY7FfWwUYABgigOxDSoATIgAKogAYgAAPEgVWHbeg4AwqgAlSHbehEo7ONjyRABhRABTQAATQ626jaCpvQHWxNsY2zLSq2xGxVsY1qx/h0jE/H+HSMT/fxyba0qL/on2zFWy81b+qj4W02aTZ5NmU2Gk1TtJ5aQ7Ph2aiK5sh9NNa/6uZx77h13DluHPeN22a6xk3jnnHLdHdEsqHeEiADCqACGoAADLAOJ3dEsoFNBGCAALpD3gAJkAEWvbprUnPXTBBAdzDXTEiADCgA64VNa2kAAjBAHMx0abgmAezn4s5K3Z01oTu0DZAAGVAAFWAzvrn7cnH3TRBAdzD3TUiADCgAW0nV3TfBlOG+TO6+CaZs/bK1OSEBTFncj7m7Hwv8WGyWbZ1OYICtVfPaWK3FPVuqe7Y09+wEVS7kni3snp1gyuKenSCA7mDre0ICZIApd3fxhAZQ5bq5i2tyF9fsLjYYLp6gyrUYqHKtBqpcm4H5kAwagACmzAamLAambOeHZJ7cDBLArmbJwC5GFtQuK82CmokmEIABAugOZqIJJmipmncmVEADmKD1wtw0QQDdwdw0IQEyoABMub3o+Q6X+88/n+7u7Nx3cf3XXcGP26e7x583Hx+fHx4+3Pzn9uF5HPTvj9vH0f68fdJvdTzuHr9pq4J/3z/cGb182H+9Hf80bd1OGOPnyllCovFvazTm0GjcaUlDthYaktY0up1jXKPXtKZBe1+6bCsatGVMiXLJaxr7eNBWD/PgEw1dZ6GRC7UjDTnRqN3MNTWqjs2KRtsu5mU7XmPnGlu/0Ohr42EnSYwHH/Yl5bMBaSkGtbbcFkU2uhBZXO39YpVti6uMLlaZtCWNRDEzpNeSNY2+56EXgiWNUmOVUaG6ptFjXqhusqix96Xmw7NQTsciLQvmtuWLE2qS1xIna4w4w7jEVY4kTntS28Vo0NpovNLgtqhxMaKytsJqr6Gh7rteI5VFjbJr5O3q8VjVaCXvGrVer9HSoka60ODrx2NRo12cxXQD8gc05Pq+SF/TyHseenlZ0qAc10rSU9r1GpUWNfbzhy6WNY2LqxwxX68hdVFjP39QT9ePx6IGb/s5iFO7XiPnRY18oSFXj8eqBtd9J8WLfnmt0a/vCy2e1y92MJTX/JLLPrd6E7Gmse/5VWOlL5wYdlFcWaWcY4vMJa30g1tDN7gt3Q1yq+VahY5LJNOSW1niRpCF+FoFTmsKMZsiK+uSe5wuuKeVHKRk5CCl0FIOlSKHujKSssUGUPSZ8JICYRxk45UVJZlTjMNWr+7FytlOUo0c9CnukgL3UFi671SFtiuUpZGM7atiXpuLmM28dAeuP+vXzWbK+yONi5l4/RSR+fwxIhTS8c0Enzzh0dt3OEvvvNuSRI07b2rHxpCTkeg9ts69l7YkwWHPztyuzqLmNYm4/i5LtI7te6djj/+2xPFjrtNJ5XgASXK8jxD+/Yfc7U+IHO40T32S9rs7falxJNHPvNpTrC9lljURijOfvtEpvCbCYVl9G3R8RbZLxaEIpzh76cuzdjwm9WxueH9avp3cBbxD5Nj87xFZzOQ31+t7RGRtdsq+jdfeHD8y304vL9t+c6RPd1dVEtFunuOF/5aK7LmcXPTfk8uxyvngUg0nMx2/n3mHCNc1Ed7iSY2+zPsTInVxTPjidCAl/QGRttidC//wyV7g/BQpu3+61OM1e/q6SDen8eBITm6m31DZ736Ujzer71E5fsn6pkrZVY5nKFlByZVvSVLiq1+TvNGbui8VqccPXd4ak4tZrv+3O/ikn26/3j+9LhC00gK7CbLKgtFWb5u35C17K9722VqlzmiT3UZom70t3lZvVU80OauQGy3738XbPlur4RltmsdZBc9oXa+5npXvjJa8ZT9OvDU9nXlyPfL8yPMj17OqHTuePD9yPfL8yPMjz8/qdew49vzY9dj12PNjz4+9v+z5WZ2O5cWuJ56feH7ielaiY8eL5yeuJ56feH7i+Vlxjh3XPb/uet31uufXPb/u/e2enxXliNdsju89v1GhNiEBfEpGhdqEiq8agAAMEBzsmaYE5QTllAEFUHFwA9BMdNS1zWMEgJwzlLPP0qhrmwDljJwzcs7IOTMORs4ZygXKBTkX5FwwGgU5m4cElW7zGORckHOBcvWJGyVvE6AMLyWYaRScTiAcjJxhqARHJVhqlMVNwGg05DxsRV4WN49Bzg05Nyg3zCAhZ7grwV4J/hplcRMwg4Sc4bEEkyW4bJTFTcBoMHIeTiMvi5vHIGdGzgxlxgwycobhEhyXYLlRFjcBMyjIGbZL8F2C8UZZ3ABYb5TFTcie6nAfyuIEZXGCsjhBcauguFVQ3Coobp2gyj17WdyEAqiABiAAAwTQHcyDE6BsHrQXAKMsbkIFmDJ7WVzvXhY3QQDdwTw4YVS2Ji+Q03OFV8g51aAWREEcJEEdNMpOrep1VMolu4KOUjmnElSDWhAFcZAEddCoRJ0UMeqIYeWFtQTVoBZEQRwkQR006lYnpaCI0SJGixgtYrSI0SJGixgtYlDEoIhBEYMiBkUMihgUMShiUMSgiMERgyMGRwyOGBwxOGJwxOCIwRGDI4ZEDIkYEjEkYkjEkIghEUMihkQMmTFebH/1dH/75eHONki2hXp+/Ir9kn78+d8f+Ab/5eLH0/evd9+en+5sb7X/vwv95y9d/h906XzSHZN+0ls+pk92EbSv9P2nWtI+JvuoWzv1mm3TUvxan1zpEPqv2/aBtvh1YRXO8Wt9R6RL79OLbfT+Bw==","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n}\n","path":"std/field/mod.nr"},"50":{"source":"use dep::sha256::sha256_var;\n\nfn main(input: [u8; 32]) -> pub [u8; 32] {\n    // Hash the full 32-byte input using sha256\n    sha256_var(input, 32)\n}\n","path":"/home/yash/Deimos/benchmarking-suite/frameworks/noir/circuits/sha256/src/main.nr"},"57":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks::<N>(message_size, h, msg_block)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let new_msg_block = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, modulo)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    let num_blocks = N / BLOCK_SIZE;\n\n    // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n    // for the given message size with a lookup.\n    //\n    // These can be reasoned about as followed:\n    // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n    // - `states[i]` should then be the state after processing the first `i` blocks.\n    // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n    // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n    //\n    // In other words:\n    //\n    // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n    // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n    //\n    // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n    let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n    let mut states: [STATE; N / BLOCK_SIZE + 1] = [h; N / BLOCK_SIZE + 1];\n\n    // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n    // no matter the value of `message_size`.\n    //\n    // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n    let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n        message_size / BLOCK_SIZE\n    } else {\n        0\n    };\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, msg_start);\n\n        blocks[i] = new_msg_block;\n        states[i + 1] = sha256_compression(new_msg_block, states[i]);\n    }\n    // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n    if N % BLOCK_SIZE != 0 {\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, BLOCK_SIZE * num_blocks);\n\n        blocks[num_blocks] = new_msg_block;\n    }\n\n    // verify the 0 padding is correct for the last block\n    let final_block = blocks[first_partially_filled_block_index];\n    verify_msg_block_zeros(final_block, message_size % BLOCK_SIZE, INT_BLOCK_SIZE);\n    (states[first_partially_filled_block_index], final_block)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) {\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = msg_item << 8;\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n        }\n    }\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, 0);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], 0);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = msg_item << 8;\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u32) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = (item << 8) + b1 as u32;\n    item = (item << 8) + b2 as u32;\n    item = (item << 8) + b3 as u32;\n    item\n}\n\nglobal BIT_SHIFT_TABLE: [u32; 4] = [1, TWO_POW_8, TWO_POW_16, TWO_POW_24];\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item * BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        if shifts >= 4 {\n            0\n        } else {\n            item >> (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item / BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let mut msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks::<N>(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/home/yash/nargo/github.com/noir-lang/sha256/v0.2.1/src/sha256.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","directive_integer_quotient","directive_to_radix"]}